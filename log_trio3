2022-06-27 12:44:20.602938+09:00 Candidate Found: fun (x:list * list) -> Nil
2022-06-27 12:44:20.614837+09:00 CEx Found: (Nil, Cons (0, Nil))
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    (x).1
2022-06-27 12:44:20.615076+09:00 Candidate Found: fix (f : list * list -> list) = fun (x:list * list) -> x . 1
2022-06-27 12:44:20.616050+09:00 CEx Found: (Cons (0, Nil), Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        Cons([O([]), Nil([])])
2022-06-27 12:44:20.618225+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) = fun (x:list * list) -> Cons (0, Nil)
2022-06-27 12:44:20.618293+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.629697+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.629749+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.639932+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.639984+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.652909+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.652954+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.663588+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.663633+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.676392+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.676439+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.689620+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.689665+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.702175+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.702222+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.718052+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.718096+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.732340+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.732389+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.746786+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.746855+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.762610+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.762662+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.777726+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.777769+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.793362+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.793405+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.810057+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.810102+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.827943+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.827992+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.846086+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.846134+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.868794+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.868836+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.888802+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.888850+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.913129+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.913172+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.935156+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.935203+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.960325+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.960373+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:20.984540+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:20.984585+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.013182+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.013230+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.040853+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.040897+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.066905+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.066947+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.105716+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.105763+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.144508+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.144557+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.182213+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.182273+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.219542+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.219593+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.257202+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.257247+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.296541+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.296592+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.338252+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.338315+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.381328+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.381376+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.423515+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.423564+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.464889+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.464933+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.505752+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.505798+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.546652+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.546696+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.594146+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.594198+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.643783+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.643834+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.691005+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.691072+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.746766+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.746816+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.801784+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.801830+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.857601+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.857646+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.910602+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.910646+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
2022-06-27 12:44:21.962481+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:44:21.962524+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

