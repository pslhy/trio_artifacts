2022-06-27 13:00:01.006648+09:00 Candidate Found: fun (x:list * list) -> Nil
2022-06-27 13:00:01.024800+09:00 CEx Found: (Nil, Cons (0, Nil))
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
(x).1
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    (x).1
convert_result
fix (f : list * list -> list) = fun (x:list * list) -> x . 1
2022-06-27 13:00:01.025020+09:00 Candidate Found: fix (f : list * list -> list) = fun (x:list * list) -> x . 1
2022-06-27 13:00:01.025958+09:00 CEx Found: (Cons (0, Nil), Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    Cons([O([]), Nil([])])
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        Cons([O([]), Nil([])])
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) = fun (x:list * list) -> Cons (0, Nil)
2022-06-27 13:00:01.028071+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) = fun (x:list * list) -> Cons (0, Nil)
2022-06-27 13:00:01.028103+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.037697+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.037744+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.046507+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.046576+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.057061+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.057114+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.069896+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.069955+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.080996+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.081041+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.094312+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.094361+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.108281+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.108326+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.120654+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.120693+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.135452+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.135496+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.148544+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.148607+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.163587+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.163633+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.180872+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.180915+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.197606+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.197658+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.218282+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.218330+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.242192+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.242255+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.265620+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.265673+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.292146+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.292199+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.317466+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.317514+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.343162+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.343209+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.370924+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.370965+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.397980+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.398030+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.428767+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.428815+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.458898+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.458945+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.489336+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.489378+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.522666+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.522714+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.556590+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.556634+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.587397+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.587443+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.620441+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.620497+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.656529+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.656571+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          (x).0
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.692303+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 13:00:01.692348+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

