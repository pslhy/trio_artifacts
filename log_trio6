synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Cons([S(O([])), Cons([O([]), Nil([])])]), Nil([])], Cons([S(O([])), Cons([O([]), Nil([])])]);[Cons([O([]), Nil([])]), Cons([O([]), Nil([])])], Cons([O([]), Cons([O([]), Nil([])])]);[Cons([S(O([])), Cons([O([]), Nil([])])]), Cons([O([]), Nil([])])], Cons([S(O([])), Cons([O([]), Cons([O([]), Nil([])])])]);[Nil([]), Nil([])], Nil([]);[Nil([]), Cons([S(S(S(O([])))), Cons([S(O([])), Nil([])])])], Cons([S(S(S(O([])))), Cons([S(O([])), Nil([])])]);[Cons([S(O([])), Cons([S(O([])), Nil([])])]), Nil([])], Cons([S(O([])), Cons([S(O([])), Nil([])])]);[Cons([S(O([])), Cons([S(S(O([]))), Nil([])])]), Cons([S(S(S(O([])))), Cons([S(S(S(S(O([]))))), Nil([])])])], Cons([S(O([])), Cons([S(S(O([]))), Cons([S(S(S(O([])))), Cons([S(S(S(S(O([]))))), Nil([])])])])])]

result
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      Cons([(Un_Cons((x).0)).0, (f [(Un_Cons((x).0)).1, (x).1])])
    
e
let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    let rec (f : ((list, list) -> list)) = 
      fun (x:(list, list)) -> 
        match (x).0 with
        Nil(_) -> 
          (x).1
        Cons(_) -> 
          Cons([(Un_Cons((x).0)).0, (f [(Un_Cons((x).0)).1, (x).1])])
        
convert_result
fix (f : list * list -> list) =
  fun (x:list * list) ->
    match x . 0 with
      | Nil _ -> x . 1
      | Cons _ -> Cons (Un_Cons (x . 0) . 0, f (Un_Cons (x . 0) . 1, x . 1))
fix (f : list * list -> list) =
  fun (x:list * list) ->
    match x . 0 with
      | Nil _ -> x . 1
      | Cons _ -> Cons (Un_Cons (x . 0) . 0, f (Un_Cons (x . 0) . 1, x . 1))
;
0.
;
0.
;
0.
;
0.
;
0.
;
0.
;
0.
;
0.
;
0.
;
0.
;
0
;
0.
;
0.
