2022-06-27 12:51:27.148398+09:00 Candidate Found: fun (x:list * list) -> Nil
2022-06-27 12:51:27.159229+09:00 CEx Found: (Nil, Cons (0, Nil))
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

(x).1
2022-06-27 12:51:27.159369+09:00 Candidate Found: fix (f : list * list -> list) = fun (x:list * list) -> x . 1
2022-06-27 12:51:27.160233+09:00 CEx Found: (Cons (0, Nil), Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    Cons([O([]), Nil([])])
2022-06-27 12:51:27.162037+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) = fun (x:list * list) -> Cons (0, Nil)
2022-06-27 12:51:27.162078+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
2022-06-27 12:51:27.171568+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:51:27.171616+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
2022-06-27 12:51:27.180878+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:51:27.180934+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
2022-06-27 12:51:27.192966+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:51:27.193014+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
2022-06-27 12:51:27.204782+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:51:27.204847+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
2022-06-27 12:51:27.220445+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:51:27.220496+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
2022-06-27 12:51:27.234715+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:51:27.234768+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
2022-06-27 12:51:27.247251+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:51:27.247304+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
2022-06-27 12:51:27.263630+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:51:27.263679+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
2022-06-27 12:51:27.277521+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:51:27.277575+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
2022-06-27 12:51:27.294921+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:51:27.294968+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
2022-06-27 12:51:27.310909+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:51:27.310983+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
2022-06-27 12:51:27.330076+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:51:27.330126+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
2022-06-27 12:51:27.346371+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:51:27.346423+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
2022-06-27 12:51:27.366878+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:51:27.366929+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
2022-06-27 12:51:27.385890+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:51:27.385942+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
2022-06-27 12:51:27.407482+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:51:27.407558+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
2022-06-27 12:51:27.430469+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:51:27.430519+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
2022-06-27 12:51:27.458182+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:51:27.458252+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

let rec (f : ((list, list) -> list)) = 
  fun (x:(list, list)) -> 
    match (x).0 with
    Nil(_) -> 
      (x).1
    Cons(_) -> 
      (x).0
    
2022-06-27 12:51:27.484629+09:00 Candidate Found: fix (f : list * list -> list) =
  fun (x:list * list) ->
    fix (f : list * list -> list) =
      fun (x:list * list) ->
        match x . 0 with
          | Nil _ -> x . 1
          | Cons _ -> x . 0
2022-06-27 12:51:27.484675+09:00 CEx Found: (Nil, Nil)
synth_type: (list, list) -> list
 ec: empty
 tc: {f -> ((list, list) -> list),
x -> (list, list)}
 td: {list -> Nil of ()
 | Cons of (nat, list),
nat -> O of ()
 | S of nat}
 vc: {Cons -> (nat, list), list,
Nil -> (), list,
O -> (), nat,
S -> nat, nat}
 spec: [[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Nil([]), Nil([])], Nil([]);[Cons([O([]), Nil([])]), Nil([])], Cons([O([]), Nil([])]);[Nil([]), Cons([O([]), Nil([])])], Cons([O([]), Nil([])])]

